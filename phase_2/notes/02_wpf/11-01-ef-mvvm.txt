To build a WPF MVVM (Model-View-ViewModel) application 
using Entity Framework with SQL Server 
in a table-first approach for Employee CRUD operations, 
follow these steps:

Prerequisites
1. Visual Studio: Install the latest version of Visual Studio 
with WPF development and SQL Server tools.
2. SQL Server: Create a database with an `Employee` table.

SQL Server Table
Create the `Employee` table in SQL Server:
```sql
Create Database HrmsAppDb;
Use HrmsAppDb;
CREATE TABLE Employee (
    Id INT PRIMARY KEY IDENTITY(1,1),
    Name NVARCHAR(50) NOT NULL,
    Age INT CHECK(Age BETWEEN 19 AND 60),
    Salary DECIMAL(18, 2),
    JobTitle NVARCHAR(20),
    ActiveStatus BIT
);

Select * From Employee;

Insert Into Employee
(Name, Age, Salary, JobTitle, ActiveStatus)
Values ('Dravid', 50, 10000, 'Coach', 1),
('Rohit', 35, 8000, 'Batsman', 1);
C:\Users\gmahe\HrmsAppDb.mdf


C:\Users\gmahe\AppData\Local\Microsoft\Microsoft SQL Server Local DB\Instances\MSSQLLocalDB\EmpAppDb.mdf



public MainWindow()
{
    InitializeComponent();
    LoadAllEmployees();
    grdEmployees.ItemsSource = AllEmployees;
}
public ObservableCollection<Employee> AllEmployees { get; set; }
public void LoadAllEmployees()
{
    var context = new HrmsAppDbEntities();
    AllEmployees = new ObservableCollection<Employee>(context.Employees.ToList());
}
```

Step-by-Step Guide to Implement WPF MVVM with Entity Framework

1. Create a WPF Application:
   - In Visual Studio, create a new WPF project.

2. Add Entity Framework for Database Interaction:
   - Install the `EntityFramework` package via NuGet.
   - Use Entity Framework Database-First approach 
   to generate models from your SQL Server database:
     1. Right-click on the project -> Add -> New Item.
     2. Select ADO.NET Entity Data Model.
     3. Choose EF Designer from database.
     4. Select the `Employee` table to generate the `Employee` class model.

3. MVVM Structure:
   - Models: `Employee.cs` is generated by Entity Framework.
   - Views: Create views 
   for List (for displaying employees), 
   Add, and Edit forms.
   - ViewModels: Create ViewModels 
   for handling UI logic 
   (EmployeeViewModel for CRUD operations).

4. Employee Model (Generated by Entity Framework):
   ```csharp
   public partial class Employee
   {
       public int Id { get; set; }
       public string Name { get; set; }
       public int Age { get; set; }
       public decimal Salary { get; set; }
       public string JobTitle { get; set; }
       public bool ActiveStatus { get; set; }
   }
   ```

5. EmployeeViewModel:
   The ViewModel will handle data binding and CRUD operations.
   ```csharp
   public class EmployeeViewModel : INotifyPropertyChanged
   {
       private EmployeeContext _context;
       private ObservableCollection<Employee> _employees;
       public ObservableCollection<Employee> Employees
       {
           get { return _employees; }
           set { _employees = value; OnPropertyChanged("Employees"); }
       }

       public EmployeeViewModel()
       {
           _context = new EmployeeContext(); // DB context
           LoadEmployees();
       }

       private void LoadEmployees()
       {
           Employees = new ObservableCollection<Employee>(_context.Employees.ToList());
       }

       public void AddEmployee(Employee employee)
       {
           _context.Employees.Add(employee);
           _context.SaveChanges();
           LoadEmployees();
       }

       public void EditEmployee(Employee employee)
       {
           var existing = _context.Employees.Find(employee.Id);
           if (existing != null)
           {
               existing.Name = employee.Name;
               existing.Age = employee.Age;
               existing.Salary = employee.Salary;
               existing.JobTitle = employee.JobTitle;
               existing.ActiveStatus = employee.ActiveStatus;
               _context.SaveChanges();
               LoadEmployees();
           }
       }

       public void DeleteEmployee(int id)
       {
           var employee = _context.Employees.Find(id);
           if (employee != null)
           {
               _context.Employees.Remove(employee);
               _context.SaveChanges();
               LoadEmployees();
           }
       }

       public event PropertyChangedEventHandler PropertyChanged;
       protected void OnPropertyChanged(string propertyName)
       {
           PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
       }
   }
   ```

6. Views:
   - EmployeeListView.xaml:
     Display the list of employees with buttons for Add, Edit, and Delete.
     ```xml
     <ListView ItemsSource="{Binding Employees}">
         <ListView.View>
             <GridView>
                 <GridViewColumn Header="ID" DisplayMemberBinding="{Binding Id}"/>
                 <GridViewColumn Header="Name" DisplayMemberBinding="{Binding Name}"/>
                 <GridViewColumn Header="Age" DisplayMemberBinding="{Binding Age}"/>
                 <GridViewColumn Header="Salary" DisplayMemberBinding="{Binding Salary}"/>
                 <GridViewColumn Header="Job Title" DisplayMemberBinding="{Binding JobTitle}"/>
                 <GridViewColumn Header="Active" DisplayMemberBinding="{Binding ActiveStatus}"/>
             </GridView>
         </ListView.View>
     </ListView>
     <Button Content="Add" Command="{Binding AddCommand}" />
     <Button Content="Edit" Command="{Binding EditCommand}" />
     ```

   - EmployeeAddEditView.xaml:
     Form for adding or editing an employee with validation and styling.
     ```xml
     <StackPanel>
         <TextBox Text="{Binding Employee.Name, ValidatesOnDataErrors=True, UpdateSourceTrigger=PropertyChanged}"/>
         <ComboBox ItemsSource="{Binding AgeOptions}" SelectedItem="{Binding Employee.Age}"/>
         <TextBox Text="{Binding Employee.Salary}"/>
         
         <!-- Job Title Radio Buttons -->
         <StackPanel Orientation="Horizontal">
             <RadioButton Content="Programmer" IsChecked="{Binding Path=Employee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Programmer'}"/>
             <RadioButton Content="Tester" IsChecked="{Binding Path=Employee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Tester'}"/>
             <RadioButton Content="Analyst" IsChecked="{Binding Path=Employee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Analyst'}"/>
             <RadioButton Content="Designer" IsChecked="{Binding Path=Employee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Designer'}"/>
         </StackPanel>

         <!-- Active Status CheckBox -->
         <CheckBox Content="Active" IsChecked="{Binding Employee.ActiveStatus}"/>

         <Button Content="Save" Command="{Binding SaveCommand}"/>
     </StackPanel>
     ```

7. Validation:
   Add validation rules for Name, Age, Salary, etc. in the ViewModel:
   ```csharp
   public string this[string columnName]
   {
       get
       {
           string result = null;
           if (columnName == "Name" && string.IsNullOrEmpty(Name))
               result = "Name is required";
           if (columnName == "Age" && (Age < 19 || Age > 60))
               result = "Age must be between 19 and 60";
           if (columnName == "Salary" && Salary <= 0)
               result = "Salary must be greater than 0";
           return result;
       }
   }
   ```

8. Styles:
   Define styles in `App.xaml` or a separate resource dictionary for consistent styling of controls:
   ```xml
   <Style TargetType="TextBox">
       <Setter Property="Margin" Value="5"/>
       <Setter Property="Padding" Value="5"/>
   </Style>
   <Style TargetType="ComboBox">
       <Setter Property="Margin" Value="5"/>
   </Style>
   <Style TargetType="Button">
       <Setter Property="Background" Value="LightBlue"/>
       <Setter Property="Padding" Value="5"/>
   </Style>
   ```

9. Job Title RadioButton Handling:
   Create a value converter to bind the job title to the radio buttons:
   ```csharp
   public class JobTitleConverter : IValueConverter
   {
       public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
       {
           return value.ToString() == parameter.ToString();
       }

       public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
       {
           return (bool)value ? parameter.ToString() : Binding.DoNothing;
       }
   }
   ```

10. Dropdown for Age:
    Populate the dropdown (ComboBox) with age options (19-60):
    ```csharp
    public ObservableCollection<int> AgeOptions { get; set; }

    public EmployeeViewModel()
    {
        AgeOptions = new ObservableCollection<int>(Enumerable.Range(19, 42));
        // Load employees...
    }
    ```

Final Steps
- Bind the `EmployeeViewModel` to the views.
- Test CRUD operations and ensure validations are triggered.
- Style the application for a polished user interface.

This setup will create a functional WPF MVVM application 
with Entity Framework, 
including CRUD operations, validation, and UI styling.


=====================================
In a WPF MVVM (Model-View-ViewModel) pattern, 
commands are used to handle UI actions, 
such as button clicks. Commands provide a clean and testable way 
to manage user interactions, and 
they are typically implemented using `ICommand` interface. 
Let me show you how commands are coded 
in the context of your application for the CRUD operations 
(Add, Edit, Delete) and handling Save/Cancel buttons.

1. Create a RelayCommand Class
First, you need a reusable class that implements `ICommand`. This class will help you bind methods to UI actions.
```csharp
using System;
using System.Windows.Input;

public class RelayCommand : ICommand
{
    private readonly Action<object> _execute;
    private readonly Func<object, bool> _canExecute;

    public event EventHandler CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }

    public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)
    {
        _execute = execute;
        _canExecute = canExecute;
    }

    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute(parameter);
    }

    public void Execute(object parameter)
    {
        _execute(parameter);
    }
}
```
2. Using Commands in `EmployeeViewModel`
In the `EmployeeViewModel`, you will create properties for each command (Add, Edit, Delete, Save, etc.) and bind them to methods that handle the respective operations.

#Example:
- AddCommand: This will open the form to add a new employee.
- EditCommand: This will load the selected employee into the form for editing.
- DeleteCommand: This will delete the selected employee from the database.

Here is how you can define and bind these commands in the ViewModel:

```csharp
public class EmployeeViewModel : INotifyPropertyChanged
{
    private EmployeeContext _context;
    private Employee _selectedEmployee;
    private ObservableCollection<Employee> _employees;

    public Employee SelectedEmployee
    {
        get { return _selectedEmployee; }
        set { _selectedEmployee = value; OnPropertyChanged("SelectedEmployee"); }
    }

    public ObservableCollection<Employee> Employees
    {
        get { return _employees; }
        set { _employees = value; OnPropertyChanged("Employees"); }
    }

    // Commands for CRUD operations
    public ICommand AddCommand { get; set; }
    public ICommand EditCommand { get; set; }
    public ICommand DeleteCommand { get; set; }
    public ICommand SaveCommand { get; set; }
    public ICommand CancelCommand { get; set; }

    public EmployeeViewModel()
    {
        _context = new EmployeeContext();
        LoadEmployees();

        // Initialize commands
        AddCommand = new RelayCommand(o => AddEmployee());
        EditCommand = new RelayCommand(o => EditEmployee(), o => SelectedEmployee != null);
        DeleteCommand = new RelayCommand(o => DeleteEmployee(), o => SelectedEmployee != null);
        SaveCommand = new RelayCommand(o => SaveEmployee(), o => CanSaveEmployee());
        CancelCommand = new RelayCommand(o => CancelOperation());
    }

    // Methods for CRUD Operations
    private void LoadEmployees()
    {
        Employees = new ObservableCollection<Employee>(_context.Employees.ToList());
    }

    private void AddEmployee()
    {
        SelectedEmployee = new Employee(); // Initialize a new employee object
    }

    private void EditEmployee()
    {
        // This will open the form with the selected employee's details
        if (SelectedEmployee != null)
        {
            // Logic to populate the Edit form with SelectedEmployee's data
        }
    }

    private void DeleteEmployee()
    {
        if (SelectedEmployee != null)
        {
            _context.Employees.Remove(SelectedEmployee);
            _context.SaveChanges();
            LoadEmployees(); // Refresh the list after deletion
        }
    }

    private void SaveEmployee()
    {
        if (SelectedEmployee.Id == 0) // If it's a new employee
        {
            _context.Employees.Add(SelectedEmployee);
        }
        else
        {
            var existing = _context.Employees.Find(SelectedEmployee.Id);
            if (existing != null)
            {
                existing.Name = SelectedEmployee.Name;
                existing.Age = SelectedEmployee.Age;
                existing.Salary = SelectedEmployee.Salary;
                existing.JobTitle = SelectedEmployee.JobTitle;
                existing.ActiveStatus = SelectedEmployee.ActiveStatus;
            }
        }

        _context.SaveChanges();
        LoadEmployees(); // Refresh the list
    }

    private bool CanSaveEmployee()
    {
        // Validation logic for enabling/disabling the Save button
        return !string.IsNullOrEmpty(SelectedEmployee.Name) && 
               SelectedEmployee.Age >= 19 && 
               SelectedEmployee.Age <= 60 && 
               SelectedEmployee.Salary > 0;
    }

    private void CancelOperation()
    {
        // Logic to cancel the operation (reset form, clear selection, etc.)
        SelectedEmployee = null;
    }

    // INotifyPropertyChanged implementation
    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

3. Binding Commands in XAML
In the XAML views, you will bind the buttons to the commands defined in the ViewModel.

#List View (for listing employees and CRUD buttons):
```xml
<ListView ItemsSource="{Binding Employees}" SelectedItem="{Binding SelectedEmployee}">
    <ListView.View>
        <GridView>
            <GridViewColumn Header="ID" DisplayMemberBinding="{Binding Id}"/>
            <GridViewColumn Header="Name" DisplayMemberBinding="{Binding Name}"/>
            <GridViewColumn Header="Age" DisplayMemberBinding="{Binding Age}"/>
            <GridViewColumn Header="Salary" DisplayMemberBinding="{Binding Salary}"/>
            <GridViewColumn Header="Job Title" DisplayMemberBinding="{Binding JobTitle}"/>
            <GridViewColumn Header="Active" DisplayMemberBinding="{Binding ActiveStatus}"/>
        </GridView>
    </ListView.View>
</ListView>

<!-- Buttons for Add, Edit, Delete -->
<Button Content="Add" Command="{Binding AddCommand}" />
<Button Content="Edit" Command="{Binding EditCommand}" />
<Button Content="Delete" Command="{Binding DeleteCommand}" />
```

#Add/Edit Form:
```xml
<StackPanel>
    <!-- TextBox for Employee Name -->
    <TextBox Text="{Binding SelectedEmployee.Name, UpdateSourceTrigger=PropertyChanged}" />

    <!-- ComboBox for Age -->
    <ComboBox ItemsSource="{Binding AgeOptions}" SelectedItem="{Binding SelectedEmployee.Age}" />

    <!-- TextBox for Salary -->
    <TextBox Text="{Binding SelectedEmployee.Salary, UpdateSourceTrigger=PropertyChanged}" />

    <!-- RadioButtons for Job Title -->
    <StackPanel Orientation="Horizontal">
        <RadioButton Content="Programmer" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Programmer'}"/>
        <RadioButton Content="Tester" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Tester'}"/>
        <RadioButton Content="Analyst" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Analyst'}"/>
        <RadioButton Content="Designer" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Designer'}"/>
    </StackPanel>

    <!-- CheckBox for Active Status -->
    <CheckBox Content="Active" IsChecked="{Binding SelectedEmployee.ActiveStatus}" />

    <!-- Save/Cancel Buttons -->
    <Button Content="Save" Command="{Binding SaveCommand}" />
    <Button Content="Cancel" Command="{Binding CancelCommand}" />
</StackPanel>
```

Key Points:
1. RelayCommand: This class simplifies the creation of commands. You can define what to execute and whether the command is currently executable using `CanExecute`.
2. Binding Commands: The commands (Add, Edit, Delete, Save, Cancel) are bound to buttons in the XAML. This ensures that UI interactions trigger the appropriate ViewModel logic.
3. Validation in `CanExecute`: The `CanExecute` method determines whether a button should be enabled or disabled (e.g., enabling Save only when the form is valid).

By organizing the logic into commands, 
you can maintain a clean separation between UI and business logic, 
making the application more testable and maintainable.
====================================




In WPF, validation rules can be applied in several ways, 
especially when working with the MVVM pattern and `ICommand` interface. 
The most common approach is to use `DataAnnotations`, 
`INotifyDataErrorInfo`, or 
`ValidationRules` in the XAML binding. 
Let's apply validation rules 
for the form fields such as Name, Age, Salary, 
Job Title, and Active Status.

1. Validation using `IDataErrorInfo` Interface
One common approach is to implement the `IDataErrorInfo` interface in your `Employee` model to handle field-level validations.

#Update the Employee Model:

```csharp
using System.ComponentModel;

public class Employee : INotifyPropertyChanged, IDataErrorInfo
{
    public int Id { get; set; }

    private string _name;
    public string Name
    {
        get { return _name; }
        set { _name = value; OnPropertyChanged("Name"); }
    }

    private int _age;
    public int Age
    {
        get { return _age; }
        set { _age = value; OnPropertyChanged("Age"); }
    }

    private decimal _salary;
    public decimal Salary
    {
        get { return _salary; }
        set { _salary = value; OnPropertyChanged("Salary"); }
    }

    private string _jobTitle;
    public string JobTitle
    {
        get { return _jobTitle; }
        set { _jobTitle = value; OnPropertyChanged("JobTitle"); }
    }

    private bool _activeStatus;
    public bool ActiveStatus
    {
        get { return _activeStatus; }
        set { _activeStatus = value; OnPropertyChanged("ActiveStatus"); }
    }

    // PropertyChanged implementation
    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    // IDataErrorInfo implementation for validation
    public string this[string columnName]
    {
        get
        {
            string result = null;

            switch (columnName)
            {
                case nameof(Name):
                    if (string.IsNullOrWhiteSpace(Name))
                        result = "Name cannot be empty.";
                    break;

                case nameof(Age):
                    if (Age < 19 || Age > 60)
                        result = "Age must be between 19 and 60.";
                    break;

                case nameof(Salary):
                    if (Salary <= 0)
                        result = "Salary must be greater than zero.";
                    break;

                case nameof(JobTitle):
                    if (string.IsNullOrEmpty(JobTitle))
                        result = "Job Title is required.";
                    break;
            }
            return result;
        }
    }

    public string Error => null; // Optional but required for IDataErrorInfo interface
}
```

- `this[string columnName]`: This method contains validation logic 
for individual properties (`Name`, `Age`, `Salary`, `JobTitle`), 
returning error messages 
if the validation fails.

2. Binding Validation in XAML
Now, you need to bind the validation logic to the input fields in the form. 
WPF uses `ValidatesOnDataErrors=True` 
to enable `IDataErrorInfo` validation for a bound field.

#Example for Add/Edit Form XAML:
```xml
<StackPanel>
    <!-- Name TextBox -->
    <TextBox Text="{Binding SelectedEmployee.Name, UpdateSourceTrigger=PropertyChanged, ValidatesOnDataErrors=True}" />
    <TextBlock Foreground="Red" Text="{Binding (Validation.Errors)[0].ErrorContent, ElementName=NameTextBox}" />

    <!-- Age ComboBox -->
    <ComboBox ItemsSource="{Binding AgeOptions}" SelectedItem="{Binding SelectedEmployee.Age, UpdateSourceTrigger=PropertyChanged, ValidatesOnDataErrors=True}" />

    <!-- Salary TextBox -->
    <TextBox Text="{Binding SelectedEmployee.Salary, UpdateSourceTrigger=PropertyChanged, ValidatesOnDataErrors=True}" />
    <TextBlock Foreground="Red" Text="{Binding (Validation.Errors)[0].ErrorContent, ElementName=SalaryTextBox}" />

    <!-- Job Title RadioButtons -->
    <StackPanel Orientation="Horizontal">
        <RadioButton Content="Programmer" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Programmer', ValidatesOnDataErrors=True}" />
        <RadioButton Content="Tester" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Tester', ValidatesOnDataErrors=True}" />
        <RadioButton Content="Analyst" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Analyst', ValidatesOnDataErrors=True}" />
        <RadioButton Content="Designer" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Designer', ValidatesOnDataErrors=True}" />
    </StackPanel>

    <!-- Active Status CheckBox -->
    <CheckBox Content="Active" IsChecked="{Binding SelectedEmployee.ActiveStatus}" />

    <!-- Save Button -->
    <Button Content="Save" Command="{Binding SaveCommand}" />
</StackPanel>
```

3. Validation Feedback in UI
To display error messages near the form fields, 
you can bind `Validation.Errors` 
to display the first validation error for each input.

For instance, to display the error message for the `Name` field:
```xml
<TextBlock Foreground="Red" Text="{Binding (Validation.Errors)[0].ErrorContent, ElementName=NameTextBox}" />
```
This ensures that validation errors are shown 
in real-time as the user interacts with the form.

4. Adding Validation for `SaveCommand`
In the `EmployeeViewModel`, ensure that the `CanExecute` logic 
for `SaveCommand` checks 
if the model is valid before allowing the save operation:
```csharp
private bool CanSaveEmployee()
{
    // Validate each field before saving
    return string.IsNullOrEmpty(SelectedEmployee["Name"]) && 
           string.IsNullOrEmpty(SelectedEmployee["Age"]) &&
           string.IsNullOrEmpty(SelectedEmployee["Salary"]) &&
           string.IsNullOrEmpty(SelectedEmployee["JobTitle"]);
}
```

5. Optional: `INotifyDataErrorInfo`
For more advanced validation scenarios, 
you can use `INotifyDataErrorInfo` instead of `IDataErrorInfo`. 
This allows for more flexibility, 
including support for asynchronous validation and multiple validation errors per property.

---

Key Points:
1. IDataErrorInfo: 
Provides a simple way to implement validation at the property level. 
You can define error messages for each field (like `Name`, `Age`, etc.).
2. XAML Binding: 
Use `ValidatesOnDataErrors=True` in the XAML 
to hook the validation logic and display error messages.
3. Error Display: 
Bind `Validation.Errors` to `TextBlock` elements 
to show error messages in the UI next to the corresponding fields.
4. Command Validation: 
Ensure `SaveCommand` only executes when the form is valid by checking if there are no errors.

This method keeps the validation logic in the model, ensuring a clean separation between UI and business rules, making the application maintainable and testable.
====================================


To implement validation using the `INotifyDataErrorInfo` interface in WPF, 
it provides more flexibility and can support multiple validation errors 
for each property. 
Here’s how to do it for your WPF application 
using MVVM with CRUD operations.

1. Implementing `INotifyDataErrorInfo` in the Model

First, let's implement the `INotifyDataErrorInfo` interface 
in the `Employee` class. 
This interface provides methods 
for asynchronous and multiple errors per property.

Updated `Employee` Model:

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;

public class Employee : INotifyPropertyChanged, INotifyDataErrorInfo
{
    public int Id { get; set; }

    private string _name;
    public string Name
    {
        get { return _name; }
        set
        {
            if (_name != value)
            {
                _name = value;
                OnPropertyChanged(nameof(Name));
                ValidateProperty(nameof(Name), _name);
            }
        }
    }

    private int _age;
    public int Age
    {
        get { return _age; }
        set
        {
            if (_age != value)
            {
                _age = value;
                OnPropertyChanged(nameof(Age));
                ValidateProperty(nameof(Age), _age);
            }
        }
    }

    private decimal _salary;
    public decimal Salary
    {
        get { return _salary; }
        set
        {
            if (_salary != value)
            {
                _salary = value;
                OnPropertyChanged(nameof(Salary));
                ValidateProperty(nameof(Salary), _salary);
            }
        }
    }

    private string _jobTitle;
    public string JobTitle
    {
        get { return _jobTitle; }
        set
        {
            if (_jobTitle != value)
            {
                _jobTitle = value;
                OnPropertyChanged(nameof(JobTitle));
                ValidateProperty(nameof(JobTitle), _jobTitle);
            }
        }
    }

    private bool _activeStatus;
    public bool ActiveStatus
    {
        get { return _activeStatus; }
        set
        {
            if (_activeStatus != value)
            {
                _activeStatus = value;
                OnPropertyChanged(nameof(ActiveStatus));
                // Assuming no validation needed for checkbox
            }
        }
    }

    // PropertyChanged event
    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    // Implementing INotifyDataErrorInfo
    private readonly Dictionary<string, List<string>> _propertyErrors = new Dictionary<string, List<string>>();

    public IEnumerable GetErrors(string propertyName)
    {
        if (string.IsNullOrEmpty(propertyName) || !_propertyErrors.ContainsKey(propertyName))
            return null;

        return _propertyErrors[propertyName];
    }

    public bool HasErrors => _propertyErrors.Count > 0;

    public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

    protected void OnErrorsChanged(string propertyName)
    {
        ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
    }

    // Validate property
    private void ValidateProperty(string propertyName, object value)
    {
        if (_propertyErrors.ContainsKey(propertyName))
        {
            _propertyErrors.Remove(propertyName); // Reset existing errors for property
        }

        var errors = new List<string>();

        switch (propertyName)
        {
            case nameof(Name):
                if (string.IsNullOrWhiteSpace((string)value))
                    errors.Add("Name cannot be empty.");
                break;

            case nameof(Age):
                if ((int)value < 19 || (int)value > 60)
                    errors.Add("Age must be between 19 and 60.");
                break;

            case nameof(Salary):
                if ((decimal)value <= 0)
                    errors.Add("Salary must be greater than zero.");
                break;

            case nameof(JobTitle):
                if (string.IsNullOrEmpty((string)value))
                    errors.Add("Job Title is required.");
                break;
        }

        if (errors.Any())
        {
            _propertyErrors.Add(propertyName, errors);
            OnErrorsChanged(propertyName);
        }
    }
}
```

Key Features of `INotifyDataErrorInfo`:
- `GetErrors(string propertyName)`: Returns the errors for the specified property.
- `HasErrors`: Indicates if there are any errors in the object.
- `ErrorsChanged` event: Triggers whenever errors change for a property.
- `ValidateProperty` method: Validates individual properties and adds error messages to `_propertyErrors`.

2. Binding Validation in XAML

To make WPF aware of these validation rules, you must bind the `Validation` behavior in the XAML using `ValidatesOnNotifyDataErrors=True`:

Example for Add/Edit Form XAML:
```xml
<StackPanel>
    <!-- Name TextBox -->
    <TextBox Text="{Binding SelectedEmployee.Name, UpdateSourceTrigger=PropertyChanged, ValidatesOnNotifyDataErrors=True}" />
    <TextBlock Foreground="Red" Text="{Binding (Validation.Errors)[0].ErrorContent, ElementName=NameTextBox}" />

    <!-- Age ComboBox -->
    <ComboBox ItemsSource="{Binding AgeOptions}" SelectedItem="{Binding SelectedEmployee.Age, UpdateSourceTrigger=PropertyChanged, ValidatesOnNotifyDataErrors=True}" />

    <!-- Salary TextBox -->
    <TextBox Text="{Binding SelectedEmployee.Salary, UpdateSourceTrigger=PropertyChanged, ValidatesOnNotifyDataErrors=True}" />
    <TextBlock Foreground="Red" Text="{Binding (Validation.Errors)[0].ErrorContent, ElementName=SalaryTextBox}" />

    <!-- Job Title RadioButtons -->
    <StackPanel Orientation="Horizontal">
        <RadioButton Content="Programmer" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Programmer', ValidatesOnNotifyDataErrors=True}" />
        <RadioButton Content="Tester" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Tester', ValidatesOnNotifyDataErrors=True}" />
        <RadioButton Content="Analyst" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Analyst', ValidatesOnNotifyDataErrors=True}" />
        <RadioButton Content="Designer" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Designer', ValidatesOnNotifyDataErrors=True}" />
    </StackPanel>

    <!-- Active Status CheckBox -->
    <CheckBox Content="Active" IsChecked="{Binding SelectedEmployee.ActiveStatus}" />

    <!-- Save Button -->
    <Button Content="Save" Command="{Binding SaveCommand}" />
</StackPanel>
```

- `ValidatesOnNotifyDataErrors=True`: 
Ensures that the validation errors 
from `INotifyDataErrorInfo` are respected 
in the UI.

3. Error Display for Each Field
To display the first validation error for each input control, 
you can use the following XAML snippet 
to bind to the `Validation.Errors` collection:

For example, for the `Name` field:
```xml
<TextBlock Foreground="Red" Text="{Binding (Validation.Errors)[0].ErrorContent, ElementName=NameTextBox}" />
```
This will display the first error message associated with the `Name` property.

4. Validation Feedback in the UI
Whenever an error occurs, the `ErrorsChanged` event is triggered, updating the error messages in real-time as the user interacts with the form.

5. Command Validation
To ensure that the form can only be submitted when all fields are valid, modify the `CanExecute` logic in the `SaveCommand` of the `EmployeeViewModel`:

```csharp
private bool CanSaveEmployee()
{
    return !SelectedEmployee.HasErrors; // Ensure that no validation errors exist
}
```

Summary:
1. INotifyDataErrorInfo: 
Provides more control over validation and 
supports multiple errors per property.
2. ValidateProperty method: 
Used to validate each property and 
update error messages dynamically.
3. ErrorsChanged event: 
Triggers when validation errors change, 
ensuring that the UI reflects real-time validation results.
4. Binding in XAML: 
Use `ValidatesOnNotifyDataErrors=True` 
to wire up validation to the input fields, 
ensuring errors are displayed as users interact with the form.
5. Command Validation: 
Ensure that the `SaveCommand` is only executable 
when the form is valid.

This method provides a robust way 
to handle validation for larger, more complex forms. 
It also offers flexibility 
by allowing for multiple errors on each property and 
supporting asynchronous validation if needed.


====================================


To apply common styles across your WPF UI, you can use resources like `Styles` and `ControlTemplates` defined in XAML. This makes your application maintainable, reusable, and visually consistent.

Here's a step-by-step guide on how to apply common styles to different UI elements for your WPF application.

1. Define Common Styles in App.xaml

In `App.xaml`, define common styles for controls such as `TextBox`, `ComboBox`, `Button`, `RadioButton`, etc. This will ensure that all instances of these controls use the defined styles across the application.

```xml
<Application x:Class="YourAppNamespace.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
        <!-- Common TextBox Style -->
        <Style TargetType="TextBox">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="Margin" Value="5"/>
            <Setter Property="Padding" Value="4"/>
            <Setter Property="BorderBrush" Value="Gray"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="VerticalContentAlignment" Value="Center"/>
        </Style>

        <!-- Common ComboBox Style -->
        <Style TargetType="ComboBox">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="Margin" Value="5"/>
            <Setter Property="Padding" Value="4"/>
            <Setter Property="BorderBrush" Value="Gray"/>
            <Setter Property="BorderThickness" Value="1"/>
            <Setter Property="VerticalContentAlignment" Value="Center"/>
        </Style>

        <!-- Common Button Style -->
        <Style TargetType="Button">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="Margin" Value="5"/>
            <Setter Property="Padding" Value="8"/>
            <Setter Property="Background" Value="#007ACC"/>
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="BorderBrush" Value="Transparent"/>
            <Setter Property="Cursor" Value="Hand"/>
        </Style>

        <!-- Common RadioButton Style -->
        <Style TargetType="RadioButton">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="Margin" Value="5"/>
            <Setter Property="Padding" Value="4"/>
        </Style>

        <!-- Common CheckBox Style -->
        <Style TargetType="CheckBox">
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="Margin" Value="5"/>
            <Setter Property="Padding" Value="4"/>
        </Style>

        <!-- Common StackPanel Style (if needed for layout consistency) -->
        <Style TargetType="StackPanel">
            <Setter Property="Margin" Value="10"/>
        </Style>

        <!-- Common Validation Error Style for TextBox -->
        <Style TargetType="TextBox" BasedOn="{StaticResource {x:Type TextBox}}">
            <Style.Triggers>
                <Trigger Property="Validation.HasError" Value="True">
                    <Setter Property="Background" Value="LightCoral"/>
                    <Setter Property="ToolTip"
                            Value="{Binding RelativeSource={RelativeSource Self}, Path=(Validation.Errors)[0].ErrorContent}" />
                </Trigger>
            </Style.Triggers>
        </Style>
    </Application.Resources>
</Application>
```

2. Explanation of Styles
- TextBox Style: Sets common properties such as `FontSize`, `Margin`, `Padding`, `BorderBrush`, and `VerticalContentAlignment` for all `TextBox` controls.
- ComboBox Style: Ensures uniform look for all `ComboBox` controls with consistent padding, margin, and font size.
- Button Style: Provides a standardized appearance with a custom background color, font size, padding, and a hover effect with the `Cursor` property.
- RadioButton and CheckBox Styles: Standardizes the appearance of these controls.
- Validation for TextBox: Applies a red background when validation fails, displaying the error message in a `ToolTip`.

3. Applying Styles Locally in a View
If you prefer applying styles locally to specific controls, you can define them directly in the XAML file for a particular window or page. Here's an example for the employee add/edit form:

```xml
<Window x:Class="YourAppNamespace.EmployeeForm"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Employee Form" Height="450" Width="600">
    <Window.Resources>
        <!-- You can define local styles here as well -->
    </Window.Resources>

    <StackPanel>
        <TextBlock Text="Employee Form" FontSize="16" FontWeight="Bold" HorizontalAlignment="Center"/>

        <!-- Name Field -->
        <TextBlock Text="Name" />
        <TextBox Text="{Binding SelectedEmployee.Name, UpdateSourceTrigger=PropertyChanged, ValidatesOnNotifyDataErrors=True}" />

        <!-- Age Field -->
        <TextBlock Text="Age" />
        <ComboBox ItemsSource="{Binding AgeOptions}" SelectedItem="{Binding SelectedEmployee.Age}" />

        <!-- Salary Field -->
        <TextBlock Text="Salary" />
        <TextBox Text="{Binding SelectedEmployee.Salary, UpdateSourceTrigger=PropertyChanged, ValidatesOnNotifyDataErrors=True}" />

        <!-- Job Title Field (RadioButtons) -->
        <TextBlock Text="Job Title" />
        <StackPanel Orientation="Horizontal">
            <RadioButton Content="Programmer" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Programmer'}"/>
            <RadioButton Content="Tester" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Tester'}"/>
            <RadioButton Content="Analyst" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Analyst'}"/>
            <RadioButton Content="Designer" IsChecked="{Binding SelectedEmployee.JobTitle, Converter={StaticResource JobTitleConverter}, ConverterParameter='Designer'}"/>
        </StackPanel>

        <!-- Active Status Field (CheckBox) -->
        <CheckBox Content="Active" IsChecked="{Binding SelectedEmployee.ActiveStatus}"/>

        <!-- Save Button -->
        <Button Content="Save" Command="{Binding SaveCommand}" />
    </StackPanel>
</Window>
```

4. Applying Styles in Code-Behind (Optional)
If you need to apply styles programmatically, you can do it in the code-behind like this:

```csharp
TextBox myTextBox = new TextBox();
myTextBox.Style = (Style)FindResource(typeof(TextBox)); // Applying the global TextBox style
```

5. Further Customization
- Triggers: You can also add triggers to handle different visual states of controls, like mouse over, focused, or validation states (as seen in the validation trigger for the `TextBox`).
- ControlTemplates: You can create more advanced control designs by overriding the `ControlTemplate`, which gives you complete control over how a control is rendered.

6. Themes (Optional)
You can also define a theme or create different resource dictionaries for light and dark themes. Define separate XAML files containing styles, and switch between them dynamically based on user preferences.

Summary:
By defining common styles in the `App.xaml` or local `Resources`, 
you ensure consistent UI styling across the entire WPF application. 
This approach promotes maintainability, 
ease of styling adjustments, and 
reusability across the app.


====================================